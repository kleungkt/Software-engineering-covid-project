package comp3111.covid;


import javafx.beans.property.SimpleFloatProperty;
import javafx.beans.property.SimpleLongProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.ScatterChart;
import javafx.scene.chart.XYChart;
import javafx.scene.control.*;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.text.Text;
import javafx.scene.text.TextBoundsType;
import javafx.util.StringConverter;
import org.apache.commons.csv.CSVRecord;
import org.controlsfx.control.CheckListView;

import java.io.FileInputStream;
import java.io.InputStream;
import java.net.URL;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
//import for C3:
import comp3111.covid.c3worldmap.*;
import org.kordamp.ikonli.materialdesign.MaterialDesign;
import javafx.event.Event;

/**
 * Building on the sample skeleton for 'ui.fxml' Controller Class generated by SceneBuilder
 */
public class Controller {
    // Task A1
    @FXML
    public TableView<Country> A1DisplayTable;
    @FXML
    public DatePicker A1Datepicker;
    @FXML
    public Button A1SearchButton;
    @FXML
    public TableColumn<Country, String> A1DisplayCountryCol;
    @FXML
    public TableColumn<Country, Long> A1DisplayTotal;
    @FXML
    public TableColumn<Country, Float> A1DisplayTotal1M;
    @FXML
    public Label A1title;
    @FXML
    public CheckListView<String> A1CheckList;

    // Task A2
    @FXML
    public DatePicker A2StartDate;
    @FXML
    public Button A2SearchButton;
    @FXML
    public Label A2title;
    @FXML
    public CheckListView<String> A2CheckList;
    @FXML
    public LineChart<Number, Number> A2Chart;
    @FXML
    public NumberAxis A2xAxis;
    @FXML
    public NumberAxis A2yAxis;
    @FXML
    public DatePicker A2EndDate;

    // Task A3
    @FXML
    public Label A3Title;
    @FXML
    public Pane A3DrawingArea;
    @FXML
    public Button A3Generate;
    @FXML
    public DatePicker A3DatePick;
    @FXML
    public Slider A3TopCountrySlider;
    @FXML
    public Button A3LoadButton;


    // Task B1
    @FXML
    public TableView<Country> B1DisplayTable;
    @FXML
    public DatePicker B1Datepicker;
    @FXML
    public Button B1SearchButton;
    @FXML
    public TableColumn<Country, String> B1DisplayCountryCol;
    @FXML
    public TableColumn<Country, Long> B1DisplayTotal;
    @FXML
    public TableColumn<Country, Float> B1DisplayTotal1M;
    @FXML
    public Label B1title;
    @FXML
    public CheckListView<String> B1CheckList;

    // Task B2
    @FXML
    public DatePicker B2StartDate;
    @FXML
    public Button B2SearchButton;
    @FXML
    public Label B2title;
    @FXML
    public CheckListView<String> B2CheckList;
    @FXML
    public LineChart<Number, Number> B2Chart;
    @FXML
    public NumberAxis B2xAxis;
    @FXML
    public NumberAxis B2yAxis;
    @FXML
    public DatePicker B2EndDate;

    // Task B3
    @FXML
    public CheckListView<String> B3CheckList;
    @FXML
    public Button B3GenerateReportButton;
    @FXML
    public Button B3ResidualPlotButton;
    @FXML
    public Button B3LinearRegressionOutputButton;
    @FXML
    public Button B3CorrelationMatrixButton;
    @FXML
    public Button B3MulticollinearityButton;
    @FXML
    public Pane B3RegressionPane;
    @FXML
    public Pane B3ResidualPane;
    @FXML
    public Pane B3CorrelationPane;
    @FXML
    public Pane B3MulticollinearityPane;
    @FXML
    public AnchorPane B3MasterPane;

    // Task C1
    public TableView<Country> C1DisplayTable;
    @FXML
    public DatePicker C1Datepicker;
    @FXML
    public Button C1SearchButton;
    @FXML
    public TableColumn<Country, String> C1DisplayCountryCol;
    @FXML
    public TableColumn<Country, String> C1DisplayVacNum;
    @FXML
    public TableColumn<Country, String> C1DisplayVacRate;
    @FXML
    public Label C1title;
    @FXML
    public CheckListView<String> C1CheckList;

    // Task C2
    @FXML
    public DatePicker C2StartDate;
    @FXML
    public Button C2SearchButton;
    @FXML
    public Label C2title;
    @FXML
    public CheckListView<String> C2CheckList;
    @FXML
    public LineChart<Number, Number> C2Chart;
    @FXML
    public NumberAxis C2xAxis;
    @FXML
    public NumberAxis C2yAxis;
    @FXML
    public DatePicker C2EndDate;

    // Task C3
    @FXML
    public AnchorPane C3MasterPane;
    @FXML
    public Button C3SearchButton;
    @FXML
    public DatePicker C3Datepicker;
    @FXML
    public Label C3title;
    @FXML
    public Label C3prompt;
    @FXML
    public AnchorPane C3WorldMapPane;
    @FXML
    public Label C3ColorScaleNoData;
    @FXML
    public Label C3ColorScale0;
    @FXML
    public Label C3ColorScale1;
    @FXML
    public Label C3ColorScale2;
    @FXML
    public Label C3ColorScale3;
    @FXML
    public Label C3ColorScale4;
    @FXML
    public Label C3ColorScale5;
    @FXML
    public Label C3ColorScale6;
    @FXML
    public ImageView C3ColorScale;
    @FXML
    public Label C3FirstTimeText;
    @FXML
    private Tab tabTaskZero;

    @FXML
    private TextField textfieldISO;

    @FXML
    private Button buttonConfirmedDeaths;

    @FXML
    private TextField textfieldDataset;

    @FXML
    private Button buttonRateOfVaccination;

    @FXML
    private Button buttonConfirmedCases;

    @FXML
    private Tab tabReport1;

    @FXML
    private Tab tabReport2;

    @FXML
    private Tab tabReport3;

    @FXML
    private Tab tabApp1;

    @FXML
    private Tab tabApp2;

    @FXML
    private Tab tabApp3;

    // Task 3 general
    @FXML
    private Tab tabBonus1;
    @FXML
    private Tab tabBonus2;
    @FXML
    private Tab tabBonus3;

    @FXML
    public TextArea textAreaConsole;

    private DateFormat dateFormatter;

    private ArrayList<Country> countriesList = new ArrayList<>();
    private HashMap<String, Country> countryISOMap = new HashMap<>();
    public ArrayList<String> listOfCountry;
    private RenjinControllerB3 rcontroller;
    private ArrayList<String> selectedPredictors;

    private A3BubbleView bubbleView;

    // error messages, for easy testing
    public final String emptyDateErrorMsg = "Date input cannot be empty.\n";
    public final String laterDateErrorMsg = "Please input a later Date.\n";
    public final String endDateEarlierErrorMsg = "End date should be later than start date.\n";
    public final String noCountryErrorMsg = "Please select at least one country.\n";

    public final String noPredictorErrorMsg = "Please select at least one variable to conduct analysis on.\n";
    public final String B3OutputOKMsg = "Linear regression report information generated! Click the corresponding buttons to view the output.\n";
    public final String RenjinErrorMsg = "Renjin exception occurred.\n";

    public final String[] nonCountryList = new String[]{
            "Asia",
            "Africa",
            "Europe",
            "European Union",
            "International",
            "North America",
            "South America",
            "World"
    };
    public final String tooManyNAErrorMsg = "The variables selected had too many NA values combined to conduct linear regression. Please select a smaller set of variables.\n";
    public final String vifNotDefinedErrorMsg = "VIF is undefined with only 1 predictor variable.\n";
    private final StringConverter<Number> converter = new StringConverter<Number>() {
        private final SimpleDateFormat dateFormatter = new SimpleDateFormat("MMM dd, yyyy", Locale.US);

        @Override
        public String toString(Number object) {
            return dateFormatter.format(new Date(object.longValue()));
        }
        @Override
        public Number fromString(String string) {
            return null;
        }
    };
    private final StringConverter<Number> percentConverter = new StringConverter<Number>() {
        @Override
        public String toString(Number object) {
            return String.format("%.2f%%", object.doubleValue() * 100);
        }

        @Override
        public Number fromString(String string) {
            return null;
        }
    };

    /**
     * Helper for DatePicker to Date format change
     *
     * @param picker DatePicker tells system which DatePicker object (on which tab) to extract the date from
     * @return date in Date format
     */
    private Date getDatePickValue(DatePicker picker) {
        try {
            LocalDate localDate = picker.getValue();
            Calendar c = Calendar.getInstance();
            c.set(localDate.getYear(), localDate.getMonthValue() - 1, localDate.getDayOfMonth(), 0, 0, 0);
            return c.getTime();
        } catch (NullPointerException e) {
            return null;
        }
    }

    /**
     * @param errCode Handle error if inputted date is lower than minimum date found in dataset
     */
    private void dateInputErrHandle(DateIncorrectException.ErrCode errCode) {
        switch (errCode) {
            case LOWER_THAN_MIN:
                textAreaConsole.setText(laterDateErrorMsg);
                break;
            default:
                break;
        }
    }

    /**
     * @return World
     * Create a World object defined in comp3111.covid.c3worldmap.World.java
     */
    private World C3GenerateWorld() {
        World C3World = WorldBuilder.create()
                .resolution(World.Resolution.HI_RES)
                .locationIconCode(MaterialDesign.MDI_STAR)
                .mousePressHandler(event -> {
                    try {
                        C3PressCountryHandler(event);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }
                })
                .zoomEnabled(false)
                .selectionEnabled(true)
                .showLocations(true)
                .prefSize(719, 360)
                .maxSize(719, 360)
                .layoutY(40)
                .scaleY(0.8)
                .build();
        return C3World;
    }

    /**
     * @param event
     * @throws ParseException Handler for clicking a country in task C3
     */
    @FXML
    void C3PressCountryHandler(Event event) throws ParseException {
        CountryPath countryPath = (CountryPath) event.getSource();
        Locale locale = countryPath.getLocale();
        String countryName = locale.getDisplayCountry();
        String countryISO = locale.getISO3Country();
        textAreaConsole.setText(countryName + " (" + countryISO + ")\n");
        Long populationNum = 0L;
        Long totalVacNum = 0L;
        Float totalVacRate = 0.0f;
        Long fullyVacNum = 0L;
        Float fullyVacRate = 0.0f;
        Long totalCaseNum = 0L;
        Float totalCasePer1M = 0.0f;
        Float totalCaseRate = 0.0f;
        Long totalDeathNum = 0L;
        Float totalDeathPer1M = 0.0f;
        Float totalDeathRate = 0.0f;
        Long newVacNum = 0L;
        Float newVacRate = 0.0f;
        Date queryDate = getDatePickValue(C3Datepicker);
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Country country = null;
        DecimalFormat decimalFormatter = new DecimalFormat("#,###.00");
        if (countryISOMap.containsKey(countryISO)) {
            country = countryISOMap.get(countryISO);
        } else {
            try {
                country = new Country(countryName, countryISO);
                countryISOMap.put(countryISO, country);
            } catch (Exception e) {
                textAreaConsole.appendText("No data found for this country!");
                return;
            }
        }
        if (queryDate == null) {
            queryDate = country.getRecentDate();
        }
        try {
            populationNum = country.getPopulation();
            textAreaConsole.appendText("Population: " + String.format("%,d", populationNum) + "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No population data available for this country!" + "\n");
            textAreaConsole.appendText(e.getMessage());
        }
        try {
            totalVacNum = country.getTotalVacNumByDate(queryDate);
            totalVacRate = country.getTotalVacRateByDate(queryDate);
            textAreaConsole.appendText("As of " +
                    dateFormat.format(queryDate) +
                    " , total vaccination number against COVID-19: " +
                    String.format("%,d", totalVacNum) +
                    " (" +
                    String.format("%.2f%%", totalVacRate * 100) +
                    ")" +
                    "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No total vaccination data available for this date!" + "\n");
        }
        try {
            fullyVacNum = country.getFullyVacNumByDate(queryDate);
            fullyVacRate = country.getFullyVacRateByDate(queryDate);
            textAreaConsole.appendText("As of " +
                    dateFormat.format(queryDate) +
                    " , fully vaccination number against COVID-19: " +
                    String.format("%,d", fullyVacNum) +
                    " (" +
                    String.format("%.2f%%", fullyVacRate * 100) +
                    ")" +
                    "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No fully vaccination data available for this date!" + "\n");
        }
        try {
            newVacNum = country.getNewVacNumByDate(queryDate);
            newVacRate = country.getNewVacRateByDate(queryDate);
            textAreaConsole.appendText("On " +
                    dateFormat.format(queryDate) +
                    " , new vaccination against COVID-19: " +
                    String.format("%,d", newVacNum) +
                    " (" +
                    String.format("%.2f%%", newVacRate * 100) +
                    ")" +
                    "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No newly vaccination data available for this date!" + "\n");
        }
        try {
            totalCaseNum = country.getTotalCasesByDate(queryDate);
            totalCasePer1M = country.getTotalCases1MByDate(queryDate);
            totalCaseRate = (float) totalCaseNum / populationNum;
            textAreaConsole.appendText("As of " +
                    dateFormat.format(queryDate) +
                    " , total COVID-19 Cases: " +
                    String.format("%,d", totalCaseNum) +
                    " (" +
                    decimalFormatter.format(totalCasePer1M) +
                    " per 1 million" +
                    ") (" +
                    String.format("%.2f%%", totalCaseRate * 100) +
                    ")" +
                    "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No cases data available for this date!" + "\n");
        }
        try {
            totalDeathNum = country.getTotalDeathsByDate(queryDate);
            totalDeathPer1M = country.getTotalDeaths1MByDate(queryDate);
            totalDeathRate = (float) totalDeathRate / populationNum;
            textAreaConsole.appendText("As of " +
                    dateFormat.format(queryDate) +
                    " , total COVID-19 Deaths: " +
                    String.format("%,d", totalDeathNum) +
                    " (" +
                    decimalFormatter.format(totalDeathPer1M) +
                    " per 1 million" +
                    ") (" +
                    String.format("%.2f%%", totalDeathRate * 100) +
                    ")" +
                    "\n");
        } catch (Exception e) {
            textAreaConsole.appendText("No death data available for this date!" + "\n");
        }
    }

    /**
     * Initialization of UI and systems
     */
    @FXML
    public void initialize() {
        Country.init();
        dateFormatter = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
        listOfCountry = DataAnalysis.getCountryNameList("COVID_Dataset_v1.0.csv");

        // task A
        A1CheckList.getItems().addAll(listOfCountry);
        A1DisplayCountryCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        A2CheckList.getItems().addAll(listOfCountry);
        A2xAxis.setTickLabelFormatter(converter);
        bubbleView = new A3BubbleView(A3DrawingArea.getPrefWidth(), A3DrawingArea.getPrefHeight());


        // task B
        B1CheckList.getItems().addAll(listOfCountry);
        B1DisplayCountryCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        B2CheckList.getItems().addAll(listOfCountry);
        B2xAxis.setTickLabelFormatter(converter);

        ArrayList<String> listOfPredictors = DataAnalysis.getMasterListOfPredictors("COVID_Dataset_v1.0.csv");
        B3CheckList.getItems().addAll(listOfPredictors);

        // don't want these buttons to be available until after generateReport is clicked
        toggleB3ButtonUsability(true);
        toggleB3DisplayPaneVisibility(null);

        // taskC
        C1CheckList.getItems().addAll(listOfCountry);
        C1DisplayCountryCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        C2CheckList.getItems().addAll(listOfCountry);
        C2xAxis.setTickLabelFormatter(converter);
        C2yAxis.setTickLabelFormatter(percentConverter);
        C2yAxis.setUpperBound(1.0f);
        C3title.setText("World Map Visualization of Fully Vaccination Rate against COVID-19");
        C3title.setTextFill(Color.web("#FFFFFF"));
        C3prompt.setText("Select a date");
        C3prompt.setTextFill(Color.web("#FFFFFF"));
        C3SearchButton.setText("Generate!");
        C3FirstTimeText.setText("Welcome to Report C - World Map Visualization of Fully Vaccinated Rate for COVID-19!" +
                "You can click on different countries to view more info, or select a different date to view the historical rates.");
        World C3World = C3GenerateWorld();
        AnchorPane C3Pane = new AnchorPane(C3World);
        C3Pane.setBackground(new Background(new BackgroundFill(C3World.getBackgroundColor(), CornerRadii.EMPTY, Insets.EMPTY)));
        C3WorldMapPane.getChildren().clear();
        C3WorldMapPane.getChildren().add(C3Pane);
        C3MasterPane.setBackground(new Background(new BackgroundFill(C3World.getBackgroundColor(), CornerRadii.EMPTY, Insets.EMPTY)));
        try {
            doC3Search(null, true);
        } catch (ParseException e) {
            System.out.println(e);
        }
    }

    /**
     * Task Zero
     * To be triggered by the "Confirmed Cases" button on the Task Zero Tab
     */
    @FXML
    void doConfirmedCases(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getConfirmedCases(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }


    /**
     * Task Zero
     * To be triggered by the "Confirmed Deaths" button on the Task Zero Tab
     */
    @FXML
    void doConfirmedDeaths(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getConfirmedDeaths(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }


    /**
     * Task Zero
     * To be triggered by the "Rate of Vaccination" button on the Task Zero Tab
     */
    @FXML
    void doRateOfVaccination(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getRateOfVaccination(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }

    /**
     * Task A1
     * Generate the table for Total Cases
     */
    @FXML
    private void doA1Search(ActionEvent actionEvent) throws ParseException {
        // if date input invalid
        if (A1Datepicker.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        // if no countries selected
        if (A1CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }

        // get Date input from the corresponding DatePicker object
        Date date = getDatePickValue(A1Datepicker);

        // title change the corresponding Label object with the corresponding message 'title'
        A1title.setText("Number of Confirmed COVID-19 Cases as of " + dateFormatter.format(date));
        // set up models
        A1DisplayTotal.setCellValueFactory(f -> {
            try {
                return new SimpleLongProperty(f.getValue().getTotalCasesByDate(date)).asObject();
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleLongProperty(0).asObject();
            }
        });
        A1DisplayTotal1M.setCellValueFactory(f -> {
            try {
                return new SimpleFloatProperty(f.getValue().getTotalCases1MByDate(date)).asObject();
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleFloatProperty(0.0f).asObject();
            }
        });
        // clear existing data
        A1DisplayTable.getItems().clear();
        A1DisplayTable.getItems().addAll(loadTable(A1CheckList.getCheckModel().getCheckedItems()));
    }

    /**
     * Task A2
     * Generate chart for cumulative cases
     */
    public void doA2Search(ActionEvent actionEvent) throws ParseException {
        if (A2StartDate.getValue() == null || A2EndDate.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        if (A2StartDate.getValue().isAfter(A2EndDate.getValue())) {
            textAreaConsole.appendText(endDateEarlierErrorMsg);
            return; // bugfix
        }
        if (A2CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }

        Date startDate = getDatePickValue(A2StartDate);
        Date endDate = getDatePickValue(A2EndDate);
        // Title change
        A2title.setText("Cumulative Confirmed COVID-19 Cases (per 1M)");

        A2Chart.getData().clear();

        // set up the range for x-axis
        A2xAxis.setAutoRanging(false);
        A2xAxis.setLowerBound(startDate.getTime());
        A2xAxis.setUpperBound(endDate.getTime());
        A2xAxis.setTickUnit((float) ((endDate.getTime() - startDate.getTime()) / 5));

        textAreaConsole.clear();

        for (String checkedCountry : A2CheckList.getCheckModel().getCheckedItems()) {
            // prepare a Country object. no need for constructor if already exists
            boolean foundCountry = false;
            Country country = null;
            for (Country value : countriesList) {
                if (value.getName().equals(checkedCountry)) {
                    foundCountry = true;
                    country = value;
                    break;
                }
            }
            if (!foundCountry) { // only call constructor if not in our list
                country = new Country(checkedCountry);
                countriesList.add(country);
            }

            // plot (date, corresponding value) in XYChart
            XYChart.Series<Number, Number> data = new XYChart.Series<Number, Number>();
            data.setName(country.getName());
            try {
                // if we just use endDate.toInstant() then it will not include endDate
                for (Date d = startDate; Date.from(endDate.toInstant().plus(1, ChronoUnit.DAYS)).after(d);
                     d = Date.from(d.toInstant().plus(1, ChronoUnit.DAYS))) {
                    data.getData().add(new XYChart.Data<Number, Number>(d.getTime(), country.getTotalCases1MByDate(d)));
                }
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
            }
            A2Chart.getData().add(data);
        }
    }

    /**
     * A3 generate the bubble graph
     *
     * @param actionEvent generated
     * @throws ParseException Fail to parse the date
     */
    @FXML
    public void doA3Generate(ActionEvent actionEvent) throws ParseException {
        // date is not entered
        if (A3DatePick.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        Date date = getDatePickValue(A3DatePick);
        // Create list of circles with name and size (cases)
        ArrayList<A3BubbleView.CircleType> circleList = new ArrayList<>();
        for (Country country : countriesList) {
            A3BubbleView.CircleType circle;
            try {
                if (country.getTotalCasesByDate(date) <= 0) {
                    continue;
                }
                circle = new A3BubbleView.CircleType(country.getTotalCasesByDate(date), country.getName());
            } catch (DateIncorrectException err) {
                // If lower than min date, not add this circle
                if (err.getErrCode() == DateIncorrectException.ErrCode.LOWER_THAN_MIN) {
                    continue;
                } else {
                    dateInputErrHandle(err.getErrCode());
                    return;
                }
            }
            circleList.add(circle);
        }
        // If no circle in list, no data found
        if (circleList.size() <= 0) {
            textAreaConsole.appendText(laterDateErrorMsg);
            return;
        }
        textAreaConsole.clear();
        A3DrawingArea.getChildren().clear();
        int topCountryNum = (int) A3TopCountrySlider.getValue();
        // some cases have ignored, hence the top x cases is changed
        if (topCountryNum >= circleList.size()) {
            topCountryNum = circleList.size();
            textAreaConsole.appendText(String.format("Some 0 cases appear, use Top %d instead\n", topCountryNum));
        }

        bubbleView.generateBubbles(circleList, topCountryNum);
        A3Title.setText(String.format("Top %d Places with the COVID-19 Infected cases", topCountryNum));
        // draw circle according to the list of circles
        for (int i = 0; i < topCountryNum; i++) {
            Circle circleShape = new Circle();
            circleShape.setCenterX(circleList.get(i).posX);
            circleShape.setCenterY(circleList.get(i).posY);
            circleShape.setRadius(circleList.get(i).radius);
            circleShape.setFill(javafx.scene.paint.Color.rgb(circleList.get(i).rgb[0], circleList.get(i).rgb[1], circleList.get(i).rgb[2]));
            A3DrawingArea.getChildren().add(circleShape);
        }

        String notShowingLabelMsg = new String("Some of the label not showing as the total cases are relatively low (Arranged in descending order): \n");
        StringBuilder notShowingCountries = new StringBuilder(new String(""));
        // put the label in the circles
        for (int i = 0; i < topCountryNum; i++) {
            if (circleList.get(i).radius >= circleList.get(0).radius / 10) {
                Text text = new Text(circleList.get(i).name);
                text.setBoundsType(TextBoundsType.VISUAL);
                text.setLayoutX(circleList.get(i).posX);
                text.setLayoutY(circleList.get(i).posY);
                A3DrawingArea.getChildren().add(text);
            } else {
                notShowingCountries.append(circleList.get(i).name).append("\n");
            }
        }
        // some circles are too small to place the label, hence ignore them and show them in the console
        if (notShowingCountries.length() != 0) {
            textAreaConsole.appendText(notShowingLabelMsg);
            textAreaConsole.appendText(notShowingCountries.toString());
        }
    }

    /**
     * load all countries from dataset
     *
     * @param actionEvent generated
     * @throws ParseException Fail to parse the date
     */
    @FXML
    public void doA3LoadAll(ActionEvent actionEvent) throws ParseException {
        ArrayList<String> sublist = new ArrayList<>(listOfCountry);
        sublist.removeAll(List.of(nonCountryList));
        CountryLoadThread multiThreadLoader = new CountryLoadThread(sublist, 4);
        multiThreadLoader.start();
        multiThreadLoader.join();
        countriesList.clear();
        countriesList.addAll(multiThreadLoader.getCountryList());
        // prepare and enable all the circles
        A3TopCountrySlider.setMin(1);
        A3TopCountrySlider.setMax(countriesList.size());
        A3TopCountrySlider.setDisable(false);
        A3TopCountrySlider.setDisable(false);
        A3DatePick.setDisable(false);
        A3Generate.setDisable(false);
        // notify finish
        textAreaConsole.appendText(String.format("loading complete, total %d places loaded\n", countriesList.size()));
    }

    /**
     * Task B1
     * Generate the table for Total Deaths
     */
    @FXML
    private void doB1Search(ActionEvent actionEvent) throws ParseException {
        // if date input invalid
        if (B1Datepicker.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        // if no countries selected
        if (B1CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }

        // get Date input from the corresponding DatePicker object
        Date date = getDatePickValue(B1Datepicker);

        // title change the corresponding Label object with the corresponding message 'title'
        B1title.setText("Number of Confirmed COVID-19 Deaths as of " + dateFormatter.format(date));

        // set up models
        B1DisplayTotal.setCellValueFactory(f -> {
            try {
                return new SimpleLongProperty(f.getValue().getTotalDeathsByDate(date)).asObject();
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleLongProperty(0).asObject();
            }
        });
        B1DisplayTotal1M.setCellValueFactory(f -> {
            try {
                return new SimpleFloatProperty(f.getValue().getTotalDeaths1MByDate(date)).asObject();
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleFloatProperty(0.0f).asObject();
            }
        });
        // clear existing data
        B1DisplayTable.getItems().clear();
        B1DisplayTable.getItems().addAll(loadTable(B1CheckList.getCheckModel().getCheckedItems()));
    }

    /**
     * Task B2
     * Generate chart for cumulative cases
     */
    public void doB2Search(ActionEvent actionEvent) throws ParseException {
        if (B2StartDate.getValue() == null || B2EndDate.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        if (B2StartDate.getValue().isAfter(B2EndDate.getValue())) {
            textAreaConsole.appendText(endDateEarlierErrorMsg);
            return;
        }
        if (B2CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }

        Date startDate = getDatePickValue(B2StartDate);
        Date endDate = getDatePickValue(B2EndDate);
        // Title change
        B2title.setText("Cumulative Confirmed COVID-19 Deaths (per 1M)");

        B2Chart.getData().clear();

        // set up the range for x-axis
        B2xAxis.setAutoRanging(false);
        B2xAxis.setLowerBound(startDate.getTime());
        B2xAxis.setUpperBound(endDate.getTime());
        B2xAxis.setTickUnit((float) ((endDate.getTime() - startDate.getTime()) / 5));

        textAreaConsole.clear();

        for (String checkedCountry : B2CheckList.getCheckModel().getCheckedItems()) {
            // prepare a Country object. no need for constructor if already exists
            boolean foundCountry = false;
            Country country = null;
            for (Country value : countriesList) {
                if (value.getName().equals(checkedCountry)) {
                    foundCountry = true;
                    country = value;
                    break;
                }
            }
            if (!foundCountry) { // only call constructor if not in our list
                country = new Country(checkedCountry);
                countriesList.add(country);
            }

            // plot (date, corresponding value) in XYChart
            XYChart.Series<Number, Number> data = new XYChart.Series<Number, Number>();
            data.setName(country.getName());
            try {
                // if we just use endDate.toInstant() then it will not include endDate
                for (Date d = startDate; Date.from(endDate.toInstant().plus(1, ChronoUnit.DAYS)).after(d);
                     d = Date.from(d.toInstant().plus(1, ChronoUnit.DAYS))) {
                    data.getData().add(new XYChart.Data<Number, Number>(d.getTime(), country.getTotalDeaths1MByDate(d)));
                }
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
            }
            B2Chart.getData().add(data);
        }
    }

    /**
     * Task B3
     * Generate the table for Total Deaths
     */
    @FXML
    public void doTaskB3(ActionEvent actionEvent) {
        // will always have this by default
        ArrayList<String> predictors = new ArrayList<>();
        predictors.add("total_deaths_per_million");

        // select predictors from dropdown GUI. If invalid:
        if (B3CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noPredictorErrorMsg);
            return;
        }
        predictors.addAll(B3CheckList.getCheckModel().getCheckedItems());

        selectedPredictors = new ArrayList<>(); // reset old values
        selectedPredictors.addAll(predictors);

        // get the predictor values for each country
        ArrayList<ArrayList<Float>> countrywisePredictors = DataAnalysis.getPredictors("COVID_Dataset_v1.0.csv", predictors);

        textAreaConsole.clear();
        // evaluate R scripts
        try {
            rcontroller = new RenjinControllerB3(countrywisePredictors);
            if (rcontroller.insufficientData == 1) {// if too many NA, and only 1 or 0 datapoints left after removing the NAs
                textAreaConsole.setText(tooManyNAErrorMsg);
                return;
            }
        } catch (Exception e) {
            textAreaConsole.appendText(RenjinErrorMsg);
            textAreaConsole.appendText(e.getMessage());
            return;
        }

        // print missing values
        String missing = "";
        for (int i = 0; i < rcontroller.naVectorJava.size(); i++) {
            missing += String.format("%s: %s\n", selectedPredictors.get(i), rcontroller.naVectorJava.get(i));
        }
        textAreaConsole.appendText("Missing values:\n" + missing);
        textAreaConsole.appendText(
                String.format("No. of missing datapoints (removed): %d, total datapoints for regression: %d\n",
                        rcontroller.totalMissing, rcontroller.totalDataPoints));
        textAreaConsole.appendText(B3OutputOKMsg);
        toggleB3ButtonUsability(false);
        toggleB3DisplayPaneVisibility(null);
    }

    @FXML
    private void generateB3ResidualPlot(ActionEvent actionEvent) {
        // only supports residual v fitted for now
        toggleB3ButtonUsability(true);

        double res_max = Math.ceil(Collections.max(rcontroller.stdResidualsJava));
        double res_min = Math.floor(Collections.min(rcontroller.stdResidualsJava));
        double other_max = Math.ceil(Collections.max(rcontroller.fittedVectorJava));
        double other_min = Math.floor(Collections.min(rcontroller.fittedVectorJava));
        double other_range = (other_max - other_min) / 4;

        NumberAxis B3xAxis = new NumberAxis(other_min, other_max, other_range);
        NumberAxis B3yAxis = new NumberAxis(res_min, res_max, 1);
        ScatterChart<Number, Number> B3ScatterChart = new ScatterChart<Number, Number>(B3xAxis, B3yAxis);
        B3ScatterChart.setTitle("Plot of std. residuals vs fitted values");
        B3yAxis.setLabel("Std. residuals");
        B3xAxis.setLabel("Fitted values");


        // plot (date, corresponding value) in XYChart
        XYChart.Series<Number, Number> data = new XYChart.Series<Number, Number>();
        data.setName("Countries (according to most recent records)");
        for (int i = 0; i < rcontroller.stdResidualsJava.size(); i++) {
            data.getData().add(new XYChart.Data<Number, Number>(
                    rcontroller.fittedVectorJava.get(i), rcontroller.stdResidualsJava.get(i)
            ));
        }
        B3ScatterChart.getData().add(data);
        // otherwise graph gets partly cutoff
        B3ScatterChart.setMaxHeight(B3ResidualPane.getPrefHeight());
        B3ScatterChart.setMaxWidth(B3ResidualPane.getPrefWidth());
        // have to do this because Scenebuilder doesn't support ScatterChart with both horizontal and vertical axes
        B3ResidualPane.getChildren().clear(); // else graphs start to be overlaid with each other
        B3ResidualPane.getChildren().add(B3ScatterChart);

        toggleB3DisplayPaneVisibility(B3ResidualPane);
        toggleB3ButtonUsability(false);
        textAreaConsole.clear();
    }

    /**
     * @param actionEvent generate linear regression in task B3
     */
    @FXML
    private void generateB3LinearReg(ActionEvent actionEvent) {
        toggleB3ButtonUsability(true);

        HBox hbox = new HBox();
        ScrollPane B3PredictorPane = new ScrollPane();
        Pane B3OutputPane = new Pane();

        B3PredictorPane.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight());
        B3OutputPane.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight());

        // display each predictor's regression coefficient and their associated p-value
        GridPane outputGridPane = new GridPane();

        Label lb00 = new Label("Variable");
        Label lb01 = new Label("Coefficient value");
        Label lb02 = new Label("p-value");
        lb00.setWrapText(true);
        lb01.setWrapText(true);
        lb02.setWrapText(true);
        outputGridPane.add(lb00, 0, 0);
        outputGridPane.add(lb01, 1, 0);
        outputGridPane.add(lb02, 2, 0);

        for (int i = 0; i < selectedPredictors.size(); i++) {
            // gridpane.add(z, x, y) adds component z to column x, row y
            String coef = String.format("%.4f", rcontroller.coefVectorJava.get(i));
            String pval = String.format("%.4f", rcontroller.pvaluesVectorJava.get(i));

            Label lb;
            // constant (beta_0) doesn't have a corresponding variable term
            if (i > 0) {
                lb = new Label(selectedPredictors.get(i));
            } else {
                lb = new Label("Constant");
            }
            Label lb2 = new Label(coef);
            Label lb3 = new Label(pval);
            lb.setWrapText(true);
            lb2.setWrapText(true);
            lb3.setWrapText(true);

            lb2.setAlignment(Pos.CENTER); // move text to center
            lb3.setAlignment(Pos.CENTER);

            lb2.setBackground(getBackgroundObjFromPVal(pval)); // get colours of each cell
            lb3.setBackground(getBackgroundObjFromPVal(pval));

            lb2.setMinSize(B3CorrelationPane.getPrefWidth() / 3,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size() + 1));
            lb3.setMinSize(B3CorrelationPane.getPrefWidth() / 3,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size() + 1));
            lb2.setMaxSize(B3CorrelationPane.getPrefWidth() / 3,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size() + 1));
            lb3.setMaxSize(B3CorrelationPane.getPrefWidth() / 3,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size() + 1));


            outputGridPane.add(lb, 0, i + 1);
            outputGridPane.add(lb2, 1, i + 1);
            outputGridPane.add(lb3, 2, i + 1);
        }

        outputGridPane.setGridLinesVisible(true);

        B3PredictorPane.setContent(outputGridPane);
        B3PredictorPane.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);
        B3PredictorPane.setHbarPolicy(ScrollBarPolicy.AS_NEEDED);

        // linear regression output relevant statistics
        VBox vbox = new VBox();
        Label multRsqLabel = new Label(String.format("Multiple R-squared: %.4f", rcontroller.multRsquaredJava));
        Label adjRsqLabel = new Label(String.format("Adjusted R-squared: %.4f", rcontroller.adjRsquaredJava));
        Label fStatLabel = new Label(String.format("F-statistic compared to intercept-only model: %.4f, on %d DF1 and %d DF2", rcontroller.fStatisticJava, rcontroller.fDF1, rcontroller.fDF2));
        Label sigmaHatLabel = new Label(String.format("Residual standard error: %.4f", rcontroller.sigmaHatJava));

        fStatLabel.setWrapText(true);
        sigmaHatLabel.setWrapText(true);
        adjRsqLabel.setBackground(new Background(new BackgroundFill(Color.GREY, CornerRadii.EMPTY, Insets.EMPTY)));
        sigmaHatLabel.setBackground(new Background(new BackgroundFill(Color.GREY, CornerRadii.EMPTY, Insets.EMPTY)));

        multRsqLabel.setMinSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        multRsqLabel.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        adjRsqLabel.setMinSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        adjRsqLabel.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        fStatLabel.setMinSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        fStatLabel.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        sigmaHatLabel.setMinSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);
        sigmaHatLabel.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                B3CorrelationPane.getPrefHeight() / 4);

        vbox.getChildren().addAll(multRsqLabel, adjRsqLabel, fStatLabel, sigmaHatLabel);
        B3OutputPane.getChildren().add(vbox);

        hbox.getChildren().addAll(B3PredictorPane, B3OutputPane);

        B3RegressionPane.getChildren().clear();
        B3RegressionPane.getChildren().add(hbox);

        toggleB3DisplayPaneVisibility(B3RegressionPane);
        toggleB3ButtonUsability(false);
        textAreaConsole.clear();
    }

    /**
     * @param actionEvent Generate Correlation Matrix in Task B3
     */
    @FXML
    private void generateB3CorrMatrix(ActionEvent actionEvent) {
        toggleB3ButtonUsability(true);


        ScrollPane corrScrollPane = new ScrollPane();
        GridPane corrGridPane = new GridPane();
        // make it so the correlation matrix never gets too big and cut off by using ScrollPane
        corrScrollPane.setMaxSize(B3CorrelationPane.getPrefWidth(), B3CorrelationPane.getPrefHeight());

        // if p predictors, total gridpane cells is (p+2)*(p+2)
        final int MAXCELLSIZE = 60;
        for (int i = 0; i < selectedPredictors.size() + 1; i++) {
            ColumnConstraints column1 = new ColumnConstraints(MAXCELLSIZE);
            corrGridPane.getColumnConstraints().add(column1);
        }
        for (int i = 0; i < selectedPredictors.size() + 1; i++) {
            RowConstraints row1 = new RowConstraints(MAXCELLSIZE);
            corrGridPane.getRowConstraints().add(row1);
        }


        // if p predictors and 1 response, need p+2 columns and rows for grid pane
        // since need 1 col x (p+1) row AND 1 row x (p+1) col in bottom left for listing each variable
        // top right (p+1)x(p+1) cells are the actual correlation values
        for (int i = 0; i < selectedPredictors.size(); i++) {
            // gridpane.add(z, x, y) adds component z to column x, row y
            Label lb = new Label(selectedPredictors.get(i));
            Label lb2 = new Label(selectedPredictors.get(i));
            lb.setWrapText(true);
            lb2.setWrapText(true);
            corrGridPane.add(lb, 0, i);
            corrGridPane.add(lb2, 1 + i, selectedPredictors.size());
            // populate grid pane with the pairwise correlations
            for (int j = 0; j < selectedPredictors.size(); j++) {
                String inp = String.format("%.3f", rcontroller.correlationMatrixJava.get(i).get(j));
                Label lbl1 = new Label(inp);
                Label lbl2 = new Label(inp);

                // make label fill to grid pane size
                lbl2.setMinSize(MAXCELLSIZE, MAXCELLSIZE);
                lbl1.setMinSize(MAXCELLSIZE, MAXCELLSIZE);

                lbl1.setBackground(getBackgroundObjFromCorr(inp)); // get colours of each cell
                lbl2.setBackground(getBackgroundObjFromCorr(inp));
                lbl1.setAlignment(Pos.CENTER); // move text to center
                lbl2.setAlignment(Pos.CENTER);

                corrGridPane.add(lbl1, j + 1, i); // upper
                corrGridPane.add(lbl2, i + 1, j); // lower
            }
        }

        corrScrollPane.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);
        corrScrollPane.setHbarPolicy(ScrollBarPolicy.AS_NEEDED);
        corrScrollPane.setContent(corrGridPane);

        B3CorrelationPane.getChildren().clear();
        B3CorrelationPane.getChildren().add(corrScrollPane);
        toggleB3DisplayPaneVisibility(B3CorrelationPane);
        toggleB3ButtonUsability(false);
        textAreaConsole.clear();
    }

    /**
     * @param actionEvent Generate Collinearity in Task B3
     */
    @FXML
    private void generateB3Collinearity(ActionEvent actionEvent) {
        toggleB3ButtonUsability(true);

        // if only simple linear regression
        if (rcontroller.VIFvector == null) {
            textAreaConsole.setText(vifNotDefinedErrorMsg);
            toggleB3DisplayPaneVisibility(null);
            toggleB3ButtonUsability(false);
            return;
        }

        GridPane vifGridPane = new GridPane();

        // grid pane needs to have (p+1) rows: 1 header row, 1 for each predictor
        // 2 columns: one displaying predictor name, other displaying VIF

        // make it so the VIF table never gets too big and cut off
        for (int i = 0; i < 2; i++) {
            ColumnConstraints column1 = new ColumnConstraints();
            column1.setHgrow(Priority.SOMETIMES);
            double max_width = B3MulticollinearityPane.getPrefWidth() / 2;
            column1.setMaxWidth(max_width);

            vifGridPane.getColumnConstraints().add(column1);
        }
        for (int i = 0; i < selectedPredictors.size(); i++) {
            RowConstraints row1 = new RowConstraints();
            row1.setVgrow(Priority.SOMETIMES);
            double max_height = B3CorrelationPane.getPrefHeight() / (selectedPredictors.size() + 1);
            row1.setMaxHeight(max_height);

            vifGridPane.getRowConstraints().add(row1);
        }

        Label lb0left = new Label("Variable");
        Label lb0right = new Label("VIF");
        lb0left.setWrapText(true);
        lb0right.setWrapText(true);
        vifGridPane.add(lb0right, 1, 0);
        vifGridPane.add(lb0left, 0, 0);

        // fill in p remaining rows and 2 columns
        for (int i = 1; i < selectedPredictors.size(); i++) {
            // gridpane.add(z, x, y) adds component z to column x, row y
            String inp = String.format("%.3f", rcontroller.VIFvector.get(i - 1));
            Label lb = new Label(selectedPredictors.get(i));
            Label lb2 = new Label(inp);
            lb.setWrapText(true);
            lb2.setWrapText(true);

            lb2.setBackground(getBackgroundObjFromVIF(inp));

            lb.setAlignment(Pos.CENTER); // move text to center
            lb2.setAlignment(Pos.CENTER);

            lb.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size()));
            lb2.setMaxSize(B3CorrelationPane.getPrefWidth() / 2,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size()));
            lb.setMinSize(B3CorrelationPane.getPrefWidth() / 2,
                    B3CorrelationPane.getPrefHeight() / (selectedPredictors.size()));

            vifGridPane.add(lb, 0, i);
            vifGridPane.add(lb2, 1, i);
        }

        vifGridPane.setGridLinesVisible(true);

        B3MulticollinearityPane.getChildren().clear();
        B3MulticollinearityPane.getChildren().add(vifGridPane);
        toggleB3DisplayPaneVisibility(B3MulticollinearityPane);
        toggleB3ButtonUsability(false);
        textAreaConsole.clear();

    }

    /**
     * @param pane Toggle Display Pane Visibility in task B3
     *             sets the corresponding pane to be visible and all others to be invisible
     */
    private void toggleB3DisplayPaneVisibility(Pane pane) {
        B3RegressionPane.setVisible(false);
        B3ResidualPane.setVisible(false);
        B3CorrelationPane.setVisible(false);
        B3MulticollinearityPane.setVisible(false);
        if (pane == null) {
            return;
        }
        pane.setVisible(true);
    }

    /**
     * @param text
     * @return helper function to set the background of a label object for a given text, which corresponds to the value of a specific pairwise correlation
     */
    private Background getBackgroundObjFromCorr(String text) {
        // assuming RGB
        // green: 0, 255, 0 (positive correlation)
        // yellow: 255, 255, 0
        // red: 255, 0, 0 (negative correlation)
        Double d = (Double.valueOf(text) + 1) / 2; // d in [0,1]
        int red = Math.min((int) Math.round(255 * 2 * (1 - d)), 255);
        int green = Math.min((int) Math.round(255 * d * 2), 255);
        Background bg = new Background(new BackgroundFill(
                Color.rgb(red, green, 0), CornerRadii.EMPTY, Insets.EMPTY));
        return bg;
    }

    /**
     * @param text
     * @return helper function to set the background of a label object for a given text, which corresponds to the value of a specific pairwise correlation
     */
    private Background getBackgroundObjFromVIF(String text) {
        // assuming RGB
        // >= 10 should be red (indicates collinearity)
        // 4-10 yellowish
        // else green
        Double d = (Double.valueOf(text) - 1) / 10; // d in [1,inf) but d originally in [1,11] will now be reduced to [0,1]
        int red = Math.min((int) Math.round(255 * 2 * d), 255);
        int green = Math.min((int) Math.round(255 * 2 * (1 - d)), 255);
        if (red < 0) {
            red = 0;
        }
        if (green < 0) {
            green = 0;
        }
        Background bg = new Background(new BackgroundFill(
                Color.rgb(red, green, 0), CornerRadii.EMPTY, Insets.EMPTY));
        return bg;
    }

    /**
     * @param text
     * @return helper function to set the background of a label object for a given text, which corresponds to the p-value of a coefficient
     */
    private Background getBackgroundObjFromPVal(String text) {
        Double d = Double.valueOf(text); // d in [0,1]
        // we want d to be green only when 0.05 or lower.
        int red = Math.min((int) Math.round(255 * 10 * d), 255);
        int green = Math.min((int) Math.round(255 * 10 * (1 - d)), 255);
        Background bg = new Background(new BackgroundFill(
                Color.rgb(red, green, 0), CornerRadii.EMPTY, Insets.EMPTY));
        return bg;
    }

    // helper function to toggle this group of buttons on/off (prevent user from spamming another button while a current button is active)
    private void toggleB3ButtonUsability(boolean bool) {
        B3ResidualPlotButton.setDisable(bool);
        B3LinearRegressionOutputButton.setDisable(bool);
        B3CorrelationMatrixButton.setDisable(bool);
        B3MulticollinearityButton.setDisable(bool);
    }

    /**
     * Task C1
     * Generate the table for Total Vaccinations
     */
    @FXML
    private void doC1Search(ActionEvent actionEvent) throws ParseException {
        // if date input invalid
        if (C1Datepicker.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        // if no countries selected
        if (C1CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }

        // get Date input from the corresponding DatePicker object
        Date date = getDatePickValue(C1Datepicker);

        // title change the corresponding Label object with the corresponding message 'title'
        C1title.setText("Rate of Vaccination against COVID-19 Deaths as of " + dateFormatter.format(date));

        // set up models
        C1DisplayVacNum.setCellValueFactory(f -> {
            try {
                return new SimpleStringProperty(String.format("%,d", f.getValue().getFullyVacNumByDate(date)));
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleStringProperty(Long.toString(0));
            }
        });
        C1DisplayVacRate.setCellValueFactory(f -> {
            try {
                return new SimpleStringProperty(String.format("%.2f%%", f.getValue().getFullyVacRateByDate(date) * 100));
            } catch (DateIncorrectException err) {
                dateInputErrHandle(err.getErrCode());
                return new SimpleStringProperty("0.00%");
            }
        });
        // clear existing data
        C1DisplayTable.getItems().clear();
        C1DisplayTable.getItems().addAll(loadTable(C1CheckList.getCheckModel().getCheckedItems()));
    }

    /**
     * Task C2
     * Generate chart for cumulative cases
     */
    public void doC2Search(ActionEvent actionEvent) throws ParseException {
        if (C2StartDate.getValue() == null || C2EndDate.getValue() == null) {
            textAreaConsole.appendText(emptyDateErrorMsg);
            return;
        }
        if (C2StartDate.getValue().isAfter(C2EndDate.getValue())) {
            textAreaConsole.appendText(endDateEarlierErrorMsg);
            return;
        }
        if (C2CheckList.getCheckModel().getCheckedItems().size() <= 0) {
            textAreaConsole.appendText(noCountryErrorMsg);
            return;
        }
        if (getDatePickValue(C2StartDate).before(dateFormatter.parse("Jan 01, 2018"))){
            textAreaConsole.appendText(laterDateErrorMsg);
            return;
        }
        Date startDate = getDatePickValue(C2StartDate);
        Date endDate = getDatePickValue(C2EndDate);
        // Title change
        C2title.setText("Cumulative Rate of Vaccination against COVID-19");

        C2Chart.getData().clear();

        // set up the range for x-axis
        C2xAxis.setAutoRanging(false);
        C2xAxis.setLowerBound(startDate.getTime());
        C2xAxis.setUpperBound(endDate.getTime());
        C2xAxis.setTickUnit((float) ((endDate.getTime() - startDate.getTime()) / 6));

        textAreaConsole.clear();

        for (String checkedCountry : C2CheckList.getCheckModel().getCheckedItems()) {
            // prepare a Country object. no need for constructor if already exists
            boolean foundCountry = false;
            Country country = null;
            for (Country value : countriesList) {
                if (value.getName().equals(checkedCountry)) {
                    foundCountry = true;
                    country = value;
                    break;
                }
            }
            if (!foundCountry) { // only call constructor if not in our list
                country = new Country(checkedCountry);
                countriesList.add(country);
            }

            XYChart.Series<Number, Number> data = new XYChart.Series<Number, Number>();
            data.setName(country.getName());
            for (Date d = startDate; Date.from(endDate.toInstant().plus(1, ChronoUnit.DAYS)).after(d);
                 d = Date.from(d.toInstant().plus(1, ChronoUnit.DAYS))) {
                try {
                    if (country.getC2VacRateByDate(d) != -1.0f)
                        data.getData().add(new XYChart.Data<Number, Number>(d.getTime(), country.getC2VacRateByDate(d)));

                } catch (DateIncorrectException err) {
                    if (err.getErrCode() == DateIncorrectException.ErrCode.LOWER_THAN_MIN)
                        data.getData().add(new XYChart.Data<Number, Number>(d.getTime(), 0));
                }
            }
            C2Chart.getData().add(data);
        }
    }

    /**
     * @param actionEvent
     * @throws ParseException
     * Overloaded function to call the main function to generate visualization map
     */
    @FXML
    private void doC3Search(ActionEvent actionEvent) throws ParseException {
        doC3Search(actionEvent, false);
    }

    /**
     * @param actionEvent
     * @throws ParseException
     * Generate visualization world map in task C3
     */
    @FXML
    private void doC3Search(ActionEvent actionEvent, boolean firstTime) throws ParseException {
        // if date input invalid
        Date date;
        if (C3Datepicker.getValue() == null) {
            date = new Date();
        } else {
            date = getDatePickValue(C3Datepicker);
        }

        // title change the corresponding Label object with the corresponding message 'title'
        C3title.setText("World Map Visualization of Fully Vaccination Rate against COVID-19 on " + dateFormatter.format(date));
        HashMap<String, Float> intensityMap = new HashMap<String, Float>();
        String iDataset = "COVID_Dataset_v1.0.csv";
        for (C3Country c3Country : C3Country.values()) {
            try {
                String iso3Key = new Locale("", c3Country.name()).getISO3Country();
                intensityMap.put(iso3Key, -1.0f);
            } catch (Exception e) {
            }
        }
        Float maxVacRate = 0.0f;
        DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy");
        for (CSVRecord rec : DataAnalysis.getFileParser(iDataset)) {
            try {

                String iso_code = rec.get("iso_code");
                String date_string = rec.get("date");
                if (!iso_code.equals("") && !date_string.equals("")) {
                    if (intensityMap.containsKey(iso_code) && (dateFormat.parse(date_string).before(date) || dateFormat.parse(date_string).equals(date))) {
                        Float vacRate = Float.parseFloat(rec.get("people_vaccinated")) / Float.parseFloat(rec.get("population"));
                        maxVacRate = Math.max(maxVacRate, vacRate);

                        intensityMap.put(iso_code, vacRate);
                    }
                }
            } catch (Exception e) {
            }
        }
        for (C3Country c3Country : C3Country.values()) {
            try {
                String iso3Key = new Locale("", c3Country.name()).getISO3Country();
                Float vacRate = intensityMap.get(iso3Key);
                Float normalizedVacRate;
                if (vacRate == -1.0f) {
                    c3Country.setColor(Color.rgb(107, 107, 107));
                } else {
                    if (maxVacRate != 0.0f)
                        normalizedVacRate = Math.abs(vacRate);
                    else
                        normalizedVacRate = 0.0f;
                    int blue = (int) (255 * (1 - normalizedVacRate)); //if norm = 0, blue = 255, if norm = 1, blue = 0
                    c3Country.setColor(Color.rgb(255, 255, blue));
                }
            } catch (Exception e) {
            }
        }

        World C3World = C3GenerateWorld();
        AnchorPane C3Pane = new AnchorPane(C3World);
        C3Pane.setBackground(new Background(new BackgroundFill(C3World.getBackgroundColor(), CornerRadii.EMPTY, Insets.EMPTY)));
        C3WorldMapPane.getChildren().clear();
        C3WorldMapPane.getChildren().add(C3Pane);
        try {
            InputStream imagePath = this.getClass().getResourceAsStream("/colorscale.jpeg");
            Image colorScaleImg = new Image(imagePath);
            C3ColorScale = new ImageView(colorScaleImg);
            C3ColorScale.setFitHeight(380);
            C3ColorScaleNoData.setText("No Data");
            C3ColorScale0.setText("0.00%");
            C3ColorScale1.setText(String.format("%.2f%%", 100.0 / 6.0));
            C3ColorScale2.setText(String.format("%.2f%%", 2 * 100.0 / 6.0));
            C3ColorScale3.setText(String.format("%.2f%%", 3 * 100.0 / 6.0));
            C3ColorScale4.setText(String.format("%.2f%%", 4 * 100.0 / 6.0));
            C3ColorScale5.setText(String.format("%.2f%%", 5 * 100.0 / 6.0));
            C3ColorScale6.setText(String.format("%.2f%%", 100.0));
            C3FirstTimeText.setText("You can click on different countries to view more info, or select a different date to view the historical rates.");
            C3WorldMapPane.getChildren().add(C3ColorScale);
            C3WorldMapPane.getChildren().add(C3ColorScaleNoData);
            C3WorldMapPane.getChildren().add(C3ColorScale0);
            C3WorldMapPane.getChildren().add(C3ColorScale1);
            C3WorldMapPane.getChildren().add(C3ColorScale2);
            C3WorldMapPane.getChildren().add(C3ColorScale3);
            C3WorldMapPane.getChildren().add(C3ColorScale4);
            C3WorldMapPane.getChildren().add(C3ColorScale5);
            C3WorldMapPane.getChildren().add(C3ColorScale6);
            C3WorldMapPane.getChildren().add(C3FirstTimeText);

        } catch (Exception e) {
            System.out.println("read image error: " + e);
        }
        if (!firstTime)
            textAreaConsole.setText("Successfully generated visualization map on " + dateFormatter.format(date));
    }

    /**
     * @param checkListCountries list of selected countries
     * @return country list
     * @throws ParseException: date validation error
     */
    private ArrayList<Country> loadTable(ObservableList<String> checkListCountries) throws ParseException {

        // check each selected country and add their info to the table
        ArrayList<Country> items = new ArrayList<>();
        for (String checkedCountry : checkListCountries) {
            // no need for constructor if already exists
            boolean foundCountry = false;
            for (Country value : countriesList) {
                if (value.getName().equals(checkedCountry)) {
                    items.add(value);
                    foundCountry = true;
                    break;
                }
            }
            if (!foundCountry) { // only call constructor if not in our list
                Country country = new Country(checkedCountry);
                items.add(country);
                countriesList.add(country);
            }
        }
        countriesList.addAll(items);
        return items;
    }


}

